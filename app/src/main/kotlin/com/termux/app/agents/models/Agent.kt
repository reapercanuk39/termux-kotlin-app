package com.termux.app.agents.models

import com.termux.app.agents.swarm.SignalType

/**
 * Agent definition loaded from YAML/JSON config.
 */
data class Agent(
    val name: String,
    val description: String,
    val version: String = "1.0.0",
    val capabilities: Set<Capability>,
    val skills: List<String>,
    val memoryBackend: MemoryBackend = MemoryBackend.JSON,
    val isBuiltin: Boolean = false,
    val isAutoGenerated: Boolean = false,
    val createdAt: Long = System.currentTimeMillis()
) {
    /**
     * Check if agent has a specific capability
     */
    fun hasCapability(capability: Capability): Boolean {
        return capabilities.contains(capability)
    }
    
    /**
     * Check if agent has capability by name
     */
    fun hasCapability(name: String): Boolean {
        return capabilities.any { it.name == name }
    }
    
    /**
     * Check if agent has a specific skill
     */
    fun hasSkill(skill: String): Boolean {
        return skills.contains(skill)
    }
    
    /**
     * Check if agent allows network access
     */
    fun allowsNetwork(): Boolean {
        return capabilities.any { it is Capability.Network.Local || it is Capability.Network.External }
    }
    
    /**
     * Check if agent allows external network access
     */
    fun allowsExternalNetwork(): Boolean {
        return capabilities.any { it is Capability.Network.External }
    }
    
    /**
     * Validate that agent can execute a command
     */
    fun canExecute(binary: String): Boolean {
        val required = Capability.getRequiredCapability(binary) ?: return true
        return hasCapability(required)
    }
    
    fun toMap(): Map<String, Any?> = mapOf(
        "name" to name,
        "description" to description,
        "version" to version,
        "capabilities" to capabilities.map { it.name },
        "skills" to skills,
        "memory_backend" to memoryBackend.name.lowercase(),
        "is_builtin" to isBuiltin,
        "is_auto_generated" to isAutoGenerated,
        "created_at" to createdAt
    )
    
    companion object {
        /**
         * Parse agent from map (YAML/JSON deserialized)
         */
        fun fromMap(map: Map<String, Any?>): Agent {
            val name = map["name"] as? String ?: throw IllegalArgumentException("Agent name required")
            val description = map["description"] as? String ?: ""
            val version = map["version"] as? String ?: "1.0.0"
            
            @Suppress("UNCHECKED_CAST")
            val capNames = map["capabilities"] as? List<String> ?: emptyList()
            val capabilities = Capability.fromStrings(capNames)
            
            @Suppress("UNCHECKED_CAST")
            val skills = map["skills"] as? List<String> ?: emptyList()
            
            val memoryBackendStr = map["memory_backend"] as? String ?: "json"
            val memoryBackend = MemoryBackend.entries.find { 
                it.name.equals(memoryBackendStr, ignoreCase = true) 
            } ?: MemoryBackend.JSON
            
            return Agent(
                name = name,
                description = description,
                version = version,
                capabilities = capabilities,
                skills = skills,
                memoryBackend = memoryBackend,
                isBuiltin = map["is_builtin"] as? Boolean ?: false,
                isAutoGenerated = map["is_auto_generated"] as? Boolean ?: false
            )
        }
    }
}

enum class MemoryBackend {
    JSON,
    DATASTORE
}

/**
 * Agent lifecycle states
 */
enum class AgentState {
    REGISTERED,
    INITIALIZING,
    READY,
    ACTIVE,
    STOPPED,
    DESTROYED,
    ERROR
}

/**
 * Runtime agent info with state
 */
data class AgentInfo(
    val agent: Agent,
    val state: AgentState = AgentState.REGISTERED,
    val lastTaskAt: Long? = null,
    val taskCount: Int = 0,
    val errorCount: Int = 0
)

/**
 * Skill definition
 */
data class Skill(
    val name: String,
    val description: String,
    val provides: List<String>,
    val requiredCapabilities: Set<Capability>,
    val isBuiltin: Boolean = true
) {
    fun toMap(): Map<String, Any?> = mapOf(
        "name" to name,
        "description" to description,
        "provides" to provides,
        "required_capabilities" to requiredCapabilities.map { it.name },
        "is_builtin" to isBuiltin
    )
    
    companion object {
        fun fromMap(map: Map<String, Any?>): Skill {
            val name = map["name"] as? String ?: throw IllegalArgumentException("Skill name required")
            val description = map["description"] as? String ?: ""
            
            @Suppress("UNCHECKED_CAST")
            val provides = map["provides"] as? List<String> ?: emptyList()
            
            @Suppress("UNCHECKED_CAST")
            val capNames = map["requires_capabilities"] as? List<String> 
                ?: map["required_capabilities"] as? List<String> 
                ?: emptyList()
            val capabilities = Capability.fromStrings(capNames)
            
            return Skill(
                name = name,
                description = description,
                provides = provides,
                requiredCapabilities = capabilities
            )
        }
    }
}
